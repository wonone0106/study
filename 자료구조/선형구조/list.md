# List
리스트는 자료를 정리하는 방법 중 하나이다.   

**데이터 구조의 모든 형태는 실제적으로 여러 종류의 리스트**를 의미한다.  
리스트는 배열과 연결리스트로 구현할 수 있음.   

**배열**로 구현할 시 **크기가 고정**됨

**연결리스트**로 구현 할 시 필요할 때 마다 **삽입, 삭제 용이**

- 리스트의 예시
    - 요일: (일요일, 월요일, ... , 토요일)
    - 한글 자음의 모임: (ㄱ, ㄴ, ... , ㅎ)

### 배열로 구현
리스트의 원소들이 기억장치의 저장 공간에 **연속적**으로 있음   

**장점** : 기억 장소의 활용도가 높고, **자주 변하지 않는 데이터의 저장**에 유리   

**단점** : 삽입, 삭제 시 데이터 이동 횟수가 많으며 여유분의 기억 장소 필요

예시)ㅤ| ㄱ | ㄴ | ㄷ | ㄹ | ㅁ |ㅤ->ㅤ( "ㄱ" 삭제 ) ->ㅤ| ㄴ | ㄷ | ㄹ | ㅁ |ㅤ|
   
예시로 보여주고 싶은 것은 "ㄱ"이 삭제 되면 **모든 데이터들이 한 칸씩 이동해야 한다는 것**이다. -> 시간 복잡도 큼

# 연결 리스트 
연결리스트는 자료를 기억하는 장소 이외에 다음 자료를 가리키는 포인터를 두어 자료의 삽입과 삭제 시 자료의 이동을 최소화 함

연결 리스트 Node의 구조   
| Data (자료 부분) -> 실제 원소 값 | Link (연결 부분) -> 다른 자료가 저장된 노드의 주소, 즉 포인터|   

이렇게 **두 부분 (Data, Link)** 으로 나뉜다.

**장점** : **노드의 삽입, 삭제가 용이**함ㅤ/ㅤ**연속적인 기억공간 없이도 저장** 가능   

**단점** : 연결부분의 사용으로 인해 배열보다 **많은 기억공간 필요**ㅤ/ㅤ알고리즘 **구현 복잡**ㅤ/ㅤ마지막 노드의 연결 부분에 NULL이 없거나 어떤 노드에서 포인터를 잃어버리면 다음 노드를 가리킬 수 없어서 **특정 노드 검색시 무한루프**에 빠질 수 있음

## 연결 리스트 구현 코드
1. 단순 연결 리스트 노드 정의
    ```c
    typedef int element;

    typedef struct ListNode{
        element data;
        struct ListNode *link;
    } ListNode;
    ```
2. 헤드 포인터 정의
    ```c
    ListNode *head = NULL;
    head = (ListNode *)malloc(sizeof(ListNode));
    ```
3. 노드의 생성
    ```c
    head->data = 10
    head->link=null;
    ```
4. 두 번째 노드 생성
    ```c
    ListNode *p;
    p = (ListNode *)malloc(sizeof(ListNode));
    p->data = 20;
    p->link = NULL;
    ```
5. 2개의 노드 연결
    ```c
    head->link = p;
    ```
### 결과
![result](./LIstEx.png)